# [level 4] 도둑질 - 42897 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42897#qna) 

### 성능 요약

메모리: 38.8 MB, 시간: 6.59 ms

### 구분

코딩테스트 연습 > 동적계획법（Dynamic Programming）

### 채점결과

정확성: 50.0<br/>효율성: 50.0<br/>합계: 100.0 / 100.0

### 제출 일자

2024년 03월 30일 20:35:02

## 💰 노트
### 1. 접근 방식
조합->검증의 dfs-backtracking 방식은 n<=1,000,000 이므로 쓸 수 없음<br/>
knapsack 문제처럼, 이번 집을 털 것인가/안 털 것인가를 선택하며 <ins>점화식을 세울 수 있고</ins> 가능한 최댓값을 구하는 문제이므로 dp 적절<br/>
### 2. 원형 구조에 따른 상황 처리
첫 번째 집-마지막 집이 인접해 있으므로, 첫 번째 집을 털 경우 마지막 집은 털지 않고, 마지막 집을 털 경우 첫 번째 집은 털지 않는데<br/>
dp 배열에는 최댓값만을 저장하므로, 첫 번째 집이 선택되었는지 여부를 저장할 수 없었다.<br/>
그래서 답을 봤는데..... 해결은 첫 번째 집~(n-1)번째 집까지 순회하거나, 두 번째~마지막 집을 순회해서 그 중 최댓값을 구하면 됨<br/>
이때 첫 번째 집을 포함해서 순회할 때, 첫 번째 집을 털지 않고 두 번째 집을 터는 경우 최댓값에 맨 마지막 집을 붙여야 하는 것 아닌가? 라고 생각했지 만..!!<br/>
두 번째 집부터 순회하는 경우에, 위 상황이 포함되기 때문에 고려하지 않아도 됨!!<br/>
그래서 달리 표현하면, <br/>
첫 번째 집부터 순회-첫 번째 집을 터는 경우 포함<br/>
두 번째 집부터 순회하는 방식-첫 번째 집을 안 터는 경우로 나눠 생각할 수 있음
### 3. 주의사항
dp[i]는 i번째 집을 꼭 터는 경우가 아니라, i번째까지 순회했을 때의 가능한 최댓값이므로, i번째 집을 털지 않는 경우가 될 수도 있음!
