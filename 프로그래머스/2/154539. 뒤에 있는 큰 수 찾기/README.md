# [level 2] 뒤에 있는 큰 수 찾기 - 154539 

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/154539#qna) 

### 성능 요약

메모리: 240 MB, 시간: 348.60 ms

### 구분

코딩테스트 연습 > 연습문제

### 채점결과

정확성: 100.0<br/>합계: 100.0 / 100.0

### 제출 일자

2024년 03월 14일 13:24:18
<br/><br/>
## 🗼노트
### 1. dp 이용
첫 시도에는 반복문을 중첩하여, 자신보다 큰 첫 번째 뒷 수가 나올 때까지 탐색하는 방법을 썼는데, 이 경우 시간복잡도가 O(n^2)이고 n<=10^6이라 시간초과가 난다.<br/>
따라서 뒤에서부터 탐색하고, 내 뒤의 있는 숫자의 뒷 큰 수 정보를 이용하면 시간을 단축할 수 있다고 생각해 dp로 접근해보기로 했다.
### 2.  첫 번째 반례
우선 경우를<br/>
1. 내 뒤의 수가 나보다 큰 수면 그 수를 뒷 큰 수로 결정<br/>
2. 내 뒤의 수가 나보다 작거나 같으면, 그 수의 뒷 큰 수와 나를 비교 후 결정<br/>

으로만 나눴는데, 이 경우 '내 뒷 수의 뒷 큰수'와 내가 같으면, '그 수'의 뒷 큰 수를 가져와야 했으므로, '그 수'의 정보를 쉽게 가져오기 위해 뒷 큰 수의 인덱스를 저장하는 배열을 추가했다.
### 3. 두 번째 반례
1. 내 뒤의 있는 수의 뒷 큰 수가 나보다 작은 수여도, 나보다 큰 어떤 수가 내 뒤 어딘가에 존재할 수 있으므로 탐색을 계속해야 함.<br/>
ex) 5 2 3 6 에서 2의 뒷 큰 수는 3으로 5보다 작음. 따라서 그 뒤를 탐색하여 6을 5의 뒷 큰 수로 결정해야 함<br/>

왜냐 하면, 내 뒤에 있는 수 중 최댓값을 저장하는 것이 아니라, 내 뒤에 있는 나보다 큰 수 중 제일 가까운 수를 저장하는 것이기 때문!<br/>
이러면 위에서 내 뒤의 수가 나보다 작거나 같을 경우의 대처를 생략했어도 될 듯
### 4. 시간 초과->시간 단축
내 뒤의 수가 나보다 작은데 뒷 큰 수가 없다==뒤에 나보다 큰 수가 존재하지 않음->뒷 큰 수 없음으로 결정 후 break하여 탐색 시간 단축
### 느낀 점
충분한 반례가 있어야 더 고민하고 경우의 수를 분기해 볼텐데...........그냥 테케 많이 만들어서 적용해보자.....
